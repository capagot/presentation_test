<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
    <script type='text/javascript' src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
  </head>

  <style>
  #container{
    position:relative;
    border:5px solid gold;
    width:800px;
    height:400px;
  }
  
  .part{position:absolute;}

  #myContainer {
    position: absolute;
    left:0;
    border:0px solid black;
  }

  #myDiv{position:relative}

  #formula{position:absolute; color:red; left:100px; top:200px}

  </style>

  <body>   
    <p><button onclick="projectVertices()">Project Vertices</button></p>
    <p><button onclick="myMove()">Click Me</button></p>
    
    <div id="myDiv">      
      <canvas id="myContainer" width=800, height=400px></canvas>
      <div id="formula"></div>
    </div>


    <script>
      // https://stackoverflow.com/questions/28284754/dragging-shapes-using-mouse-after-creating-them-with-html5-canvas
      
		
  
			var canvas = document.getElementById("myContainer");
      var ctx = canvas.getContext("2d");     
      var BB=canvas.getBoundingClientRect();
      var offsetX=BB.left;
      var offsetY=BB.top;
			var isDragging = false;
			var msg = {text:'-----', x:20, y:200};
      
      var leftChart = {scrTopLeft: [30, 70], 
                       scrWidth: 300, 
                       scrHeight: 300, 
                       domXTick: 3, 
                       domYTick: 3, 
                       domXMin: 0,
                       domXMax: 18,
                       domYMin: 0,
                       domYMax: 18}

      var rightChart = {scrTopLeft: [400, 70], 
                        scrWidth: 300, 
                        scrHeight: 300, 
                        domXTick: 3, 
                        domYTick: 3, 
                        domXMin: 0,
                        domXMax: 18,
                        domYMin: 0,
                        domYMax: 18}
                      
			var circle = {scrCenter: [150, 200],
                    scrRadius: 10, 
										domCenter: [10, 15],
                    color: "#800080", 
                    isDragging: false}
                   
      var blueBase = {domBase: [[1, 0], [0, 1]], // base
      								domOrigin: [[10], [10]], 
                      color: 'rgb(255, 0, 0)', 
                      isDragging: false}
       
       
      var shapes = [];
      
      shapes.push(circle);
      shapes.push(blueBase);
      
      canvas.onmousedown = myDown;
      canvas.onmouseup = myUp;
      canvas.onmousemove = myMove;
      
      Draw(ctx);
      
			function myDown(event) {    
  			// tell the browser we're handling this mouse event      
        event.preventDefault();
        event.stopPropagation();
        
        // get the current mouse position
        var mouseX = parseInt(event.clientX - offsetX);
        var mouseY = parseInt(event.clientY - offsetY);                
        
        //var dx = circle.x - mx;
        //var dy = circle.y - my;
        
        //// test if the mouse is inside this circle
        //if(dx * dx + dy * dy < circle.r * circle.r) {
        //  is_dragging = true;
        //  circle.isDragging = true;
        //}
            
      	for (var i = 0; i < shapes.length; ++i) {
        	if (shapes[i].scrRadius) {
          	var dx = shapes[i].scrCenter[0] - mouseX;
            var dy = shapes[i].scrCenter[1] - mouseY;
            
            if(dx * dx + dy * dy < shapes[i].scrRadius * shapes[i].scrRadius) {
              isDragging = true;
              shapes[i].isDragging = true;
            }                        
          } else {
          	scrOrigin = grid2Screen(leftChart, shapes[i].domOrigin[0][0], shapes[i].domOrigin[1][0]);
          	var dx = scrOrigin[0] - mouseX;
            var dy = scrOrigin[1] - mouseY;

            if(dx * dx + dy * dy < 50 * 50) {
            //if ((mouseX > scrOrigin[0] - 100) && (mouseX < scrOrigin[0] + 100) && 
            //    (mouseY > scrOrigin[1] - 100) && (mouseY < scrOrigin[1] + 100)) {
              isDragging = true;
              shapes[i].isDragging = true;
            }
          }
        }

        // save the current mouse position
        startX = mouseX;
        startY = mouseY;      
      }

			function myUp(event){
        // tell the browser we're handling this mouse event
        event.preventDefault();
        event.stopPropagation();

        // clear all the dragging flags
        isDragging = false;

				for (var i = 0; i < shapes.length; ++i)
        	shapes[i].isDragging = false;
      }
      
      function myMove(event){   
       	if (isDragging) {
          // tell the browser we're handling this mouse event
          event.preventDefault();
          event.stopPropagation();

          // get the current mouse position
          var mouseX = parseInt(event.clientX - offsetX);
          var mouseY = parseInt(event.clientY - offsetY);

          // calculate the distance the mouse has moved
          // since the last mousemove
          var dx = mouseX - startX;
          var dy = mouseY - startY;
          
          [domStartX, domStartY] = Screen2Grid(leftChart, startX, startY);
          [domMX, domMY] = Screen2Grid(leftChart, mouseX, mouseY);
          
          var domDx = domMX - domStartX;
          var domDy = domMY - domStartY;
                    
      		for (var i = 0; i < shapes.length; ++i) {
            if (shapes[i].isDragging) {
              if (shapes[i].scrRadius) {
                shapes[i].scrCenter[0] += dx;
                shapes[i].scrCenter[1] += dy;
              } else {
              	//shapes[i].domOrigin[0][0] += 0.1 * dx;
              	//shapes[i].domOrigin[1][0] += 0.1 * -dy;
              	shapes[i].domOrigin[0][0] += domDx;
              	shapes[i].domOrigin[1][0] += domDy;
              }
            }
          }
          
          Draw(ctx);
          
          // reset the starting mouse position for the next mousemove
          startX = mouseX;
          startY = mouseY;    
        }
      }
      
      function Draw(ctx) {
        ctx.fillStyle = "black";
				ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.translate(0.5, 0.5);
        
        ctx.font = "30px Arial";
        ctx.fillStyle = 'rgb(200, 200, 200)';
        ctx.fillText("Hello World", 30, 40);
        ctx.fillText("Hello World", 400, 40);               
        
        //document.querySelector('#formula').textContent = '$' + circle.scrCenter[0] + '$';
        
        //var ddd = document.getElementById("formula");

var a = 100;
var b = 1;
var c = -10;
        
        Draw2DGrid(leftChart);
        Draw2DGrid(rightChart);      
        drawCircle(circle);
        drawBase(leftChart, blueBase, 8);
        //ShowMessage(msg);
               
        ctx.translate(-0.5, -0.5);
        
	var tex1 = katex.renderToString('\\begin{bmatrix}' + a + ' & \\textcolor{white}{' + circle.scrCenter[0] + '} & ' + c + '\\\\a & b & c \\end{bmatrix}', {throwOnError: false,});
  
	document.getElementById("formula").innerHTML = tex1;  
        
      }
      
      function grid2Screen(grid, x, y) {
      	var x_screen = grid.scrTopLeft[0] + x * grid.scrWidth / (grid.domXMax - grid.domXMin);
      	var y_screen = (grid.scrTopLeft[1] + grid.scrHeight) - y * grid.scrHeight / (grid.domYMax - grid.domYMin);
        return [Math.trunc(x_screen), Math.trunc(y_screen)];
      }

      function Screen2Grid(grid, x, y) {
        var domX = (x - grid.scrTopLeft[0]) * (grid.domXMax - grid.domXMin) /  grid.scrWidth;       
      	var domY = -(y - (grid.scrTopLeft[1] + grid.scrHeight)) * (grid.domYMax - grid.domYMin) / grid.scrHeight;
        
        return [domX, domY];
      }

      function drawBase(grid, base, size) {
       
        [x, y] = grid2Screen(grid, base.domOrigin[0][0], base.domOrigin[1][0]);
        [x1, y1] = grid2Screen(grid, 
                               base.domOrigin[0][0] + size * base.domBase[0][0], 
                               base.domOrigin[1][0] + size * base.domBase[0][1]);
        [x2, y2] = grid2Screen(grid, 
                               base.domOrigin[0][0] + size * base.domBase[1][0], 
                               base.domOrigin[1][0] + size * base.domBase[1][1]);
                               
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x1, y1);
        ctx.moveTo(x, y);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = base.color;
        ctx.stroke();
        ctx.closePath();
      }

			function ShowMessage(msg) {
        ctx.font = "15px Arial";
        ctx.fillStyle = 'rgb(0, 255, 0)';
        ctx.fillText(msg.text, msg.x, msg.y);
			}

			function drawCircle(circle) {
        ctx.fillStyle=circle.color;
        ctx.beginPath();
        ctx.arc(circle.scrCenter[0], circle.scrCenter[1], circle.scrRadius, 0, Math.PI*2);
        ctx.closePath();
        ctx.fill();
      }
            
			function Draw2DGrid({scrTopLeft, 
      										 scrWidth, 
                           scrHeight, 
                           domXTick, 
                           domYTick,
                           domXMin,
                           domXMax, 
                           domYMin,
                           domYMax}) {
        
        var x_end = scrTopLeft[0] + scrWidth;
        var y_end = scrTopLeft[1] + scrHeight;

        ctx.lineWidth = 1;
        ctx.beginPath();

				x_screen = scrTopLeft[0];
        dx = domXTick * scrWidth / (domXMax - domXMin);
				for (x_curr = domXMin; x_curr <= domXMax; x_curr += domXTick) {
          ctx.moveTo(Math.trunc(x_screen), scrTopLeft[1]);
          ctx.lineTo(Math.trunc(x_screen), y_end);          
          x_screen += dx;
        }
        
				y_screen = scrTopLeft[1];
        dy = domYTick * scrHeight / (domYMax - domYMin);
				for (y_curr = domYMin; y_curr <= domYMax; y_curr += domYTick) {
          ctx.moveTo(scrTopLeft[0], Math.trunc(y_screen));
          ctx.lineTo(x_end, Math.trunc(y_screen));
          y_screen += dy;
        }

        ctx.strokeStyle = 'rgb(64, 64, 64)';
        ctx.stroke();
        ctx.closePath();

        ctx.font = "10pt Arial";
        ctx.fillStyle = 'rgb(255, 255, 255)';

				x_screen = scrTopLeft[0];
				for (x_curr = domXMin; x_curr <= domXMax; x_curr += domXTick) {
          var r = Math.round(x_curr * 10) / 10;
          var half_text_w = ctx.measureText(r).width / 2;   
          var half_text = parseInt(ctx.font);
          ctx.fillText(r, x_screen - half_text_w, scrTopLeft[1] + scrHeight + half_text);
          x_screen += dx;
        }

				y_screen = scrTopLeft[1] + scrHeight;
				for (y_curr = domYMin; y_curr <= domYMax; y_curr += domYTick) {
          var r = Math.round(y_curr * 10) / 10;
          var text_w = ctx.measureText(r).width;    
          ctx.fillText(r, scrTopLeft[0] - text_w - 6, y_screen + 6);
          y_screen -= dy;
        }

				ctx.lineWidth = 0.8;
        ctx.strokeStyle = 'rgb(128, 128, 128)';
        ctx.strokeRect(scrTopLeft[0], scrTopLeft[1], scrWidth, scrHeight);       
      }

    </script>
  </body>
</html>
